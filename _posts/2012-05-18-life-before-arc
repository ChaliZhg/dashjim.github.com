---
layout: post
title: Life Before ARC
categories:
- Programming
tags:
- iOS
- alloc
- autorelease
---

最近在看一本书, 书名是 "Pro Multithreading and Memory Management for iOS and OS X",主要讲内存管理及多线程相关内容的.   
![Pro.Multithreading.and.Memory.Management.for.iOS.and.OS.X](http://farm6.staticflickr.com/5240/7221562548_c08c9b581f_n.jpg)

第一章讲的便是手动管理内存的相关知识,本文为自己看过后的总结.
<br>
### 一.概述   

Objc和其他许多高级语言一样在对象的内存管理方便都使用了引用计数的方案.

- 如果你创建了一个对象,你便拥有这个对象,此时对象的引用计数为1,
- 当你想拥有一个不是你创建的对象的时候，可以对其使用retain方法,引用计数加1
- 当你用完了一个对象无需再时候的时候，你需要对其使用release方法释放拥有权,这时引用计数减1
- 当一个对象的引用计数为0的时候,其dealloc方法将被调用将其销毁
- 当一个对象被销毁后,你还通过其先前的引用进行操作,那就可能引发crash或者不可预料的异常,这是非常危险的.


用来创建对象的方法的名称都是有一定的规律的,方法为以下或者以以下各种方法名打头的方法(但必须遵守驼峰命名规则,比如newer便不可以用作创建对象的方法名)都是用来创建对象的,在我们自己定义的用来创建对象的方法也需要遵守此规则

- alloc 分配内存
- new  NSObject中[NSObject new]等同于 [[NSObject alloc] init]
- copy 复制出一个新对象
- mutableCopy 复制出一个可变(如数组可增删对象)的新对象

<br>

如果一个函数返回一个新创建的对象 比如 [NSArray array] 这样的,调用者对返回的对象并没有拥有权,但是在返回的时候新建的对象又不能在返回前释放,那该如何实现呢?
下面是一个解决此类问题的例子

{% highlight objc %}
- (id)object{
	id obj = [[NSObject alloc] init];//创建对象
	[obj autorelease];//释放对象的所有权,这个时候对象并不会立即销毁,因为此时对象的所有者为当前活动的autoreleasePool
	return obj;//返回对象
}
{% endhighlight %}

当某个对象调用autorelease方法后,其会被加入autoreleasePool,当autoreleasePool清空的时候，这个对象会被释放并销毁.
   
<br>
### 二.引用计数的实现原理

<br>
### 三.自动释放池(NSAutoreleasePool)的实现原理


